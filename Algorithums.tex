% Created 2021-12-23 Thu 17:23
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\author{Atharv Sule}
\date{\today}
\title{Algorithms}
\hypersetup{
 pdfauthor={Atharv Sule},
 pdftitle={Algorithms},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.4.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\part{Fundamentals}
\label{sec:org7f2409c}
\chapter{Summary of topics}
\label{sec:org7d25c30}
\begin{itemize}
\item You can run algorithms to study their properties
\item You can put them to good use immediately in applications
\end{itemize}
\begin{itemize}
\item Programming constructs(building blocks), software libraries( programmming concepts),
and operating systems used to impemet programs make up our
peogramming model
\item To understand this model let us frist talk about statements
\item Here are the different types of statements:
\begin{itemize}
\item Declarations: reate specific type of variables and name w
identifiers
\item Assignments: associate data type with variable
\item Conditionals: provide change in execution flow
\item Loops: more profound change in execution flow, repeat block mutiple times
\item Call and returns relate static methods
\end{itemize}
\item arrays store a sequence of values
\begin{itemize}
\item to initalize an array declare array name and type,create the array
\end{itemize}
initalxe the values
\begin{itemize}
\item Defalt values are set to zero, you initalze them through a for loop
\end{itemize}
\item Static methods: can bel declared without the name of the method, declare class
name
\begin{itemize}
\item Here's an example static method:
\begin{minted}[]{java}
public static squrt(double c)
\end{minted}
\end{itemize}
\item properties of methods
\begin{itemize}
\item Methods can be overloaded
\item methods have a single return value but can have mulitple return statements
\item A method can have side effects
\end{itemize}
\item Recursion: method will call intself
\item External Libraries: imported statements (ex: \texttt{java.lang.*})
\end{itemize}
\section{Subheading}
\label{sec:orgeeaa098}
\chapter{Data Abstraction}
\label{sec:org02be6ea}
\begin{itemize}
\item Abstract data type: data type whose representation is hidden from the client
\item Abstract data types are important because they support encapsulation.
\item You do not need to know the data type implemented in order to be able to use it
\item Objects are characterized by three properties: state, identity, behavior
\item State: value from its data type
\item Identity: distinguishes one object from another.
\item Behavior: are an objects predefined functions.
\item Reference: means of accessing an object
\item To invoke methods, you would put the class name "." and then the method
name
\item For Example:
\begin{minted}[]{java}
Counter heads = new Counter("heads");
heads.increment();
\end{minted}
\item The primary purpose of static methods is to implement functions,
while non-static methods implement data-type operations
\item Aliasing: both variables refer to the same object
\item For Example:
\begin{minted}[]{java}
Counter c1 = new Counter("ones");
c1.increment();
Counter c2 = c1;
c2.increment;
stdOut.println(c1);
\end{minted}
\item you can pass objects as arguments to methods, java passes
a copy of the argument value from the calling program to the
method(cannot change value of the variable
\item All nonprimitve types are objects so in a way arrays are objects
\item \(e=mc^2\)
\item Writing code that refers to data abstraction is referred to as
object-oriented programming
\item This is displalystyle: $$e=mc^2$$
\item (ADT): to simplify client code
\item \texttt{In} Class allows multiple lines of code
\item Constructor-initiates instance variables
\item Scope:(parameter: the method, Local: the block statement, Instance: whole class)

\item Instace methods: behavior of class

\item Sometimes you need to maintain two implementations
one for clients and another for other people

\item immutable data type: value never changes once cons

\item Algorithms is an implementation of an is the implementation of an
instance method in an absract data type

\item Data absraction is good for algorithms because it is a framework
because it specifies what the algorithms need to accomplish and how the client
can make use of it
\end{itemize}
\chapter{Bags, Queues, and Stacks}
\label{sec:org7d49583}
\begin{itemize}
\item several fundemental data types involve collection of objects
\item bag queu and stack are essiential in unfersanding algorithums
\item parameterized types- pass in what type of data that you want to use
\item EX:
\begin{minted}[]{java}
     Stack<String> stack = new Stack<String>();
     stack.push("Test");

     String next = stack.pop();
     #+end_src java
   - Casting a primitve type as a wrapper
   - FIFO queue- first to leave and frit to ender polcy
   - pushdown stack- based on first in frist out
   - Arithmeic: below is an example of how arithmetic is used in java 
      #+begin_src java
 import java.util.Stack;
import java.util.*;

public class Evaluate {
    public static void main(String[] args) {
	Stack<String> ops = new  Stack<String>();
	Stack<Double> vals = new  Stack<Double>();

	// if array args length is equal to zero then the length is zero
//        if (args.length == 0) {
//            System.out.println("Usage:expression");
//            return;
//        }
	String arg1 = args[0];
	int charIndex = 0;
	System.out.println(arg1.length());
	while (charIndex < arg1.length()){
	    char stringChar = arg1.toCharArray()[charIndex++];
	    String s ="" + stringChar;
	    if(s.equals("(")) {

	    }else if (s.equals("+")){
		ops.push(s);
	    } else if(s.equals("-")){
		ops.push(s);
	    }else if (s.equals("*")){
		ops.push(s);
	    }else if(s.equals("/")){
		ops.push(s);
	    }else if (s.equals("sqrt")){
		ops.push(s);
	    }else if (s.equals(")")){
		String op = ops.pop();
		double v = vals.pop();
		if(op.equals("+")){
		    v = vals.pop() + v;
		}else if (op.equals("-")){
		    v = vals.pop() -v;
		}else if(op.equals("*")){
		    v = vals.pop() *v;
		}else if (op.equals("/")){
		    v = vals.pop()/ v;
		}else if(op.equals("sqrt")){
		    v = Math.sqrt(v);
		}
		vals.push(v);
	    }else{
		vals.push(Double.parseDouble(s));
	    }
	};
	System.out.println(vals.pop());
    }
}

\end{minted}
\item abstact data type is a fixed capacity stack
\item fixed capacity stack only works for strings
\item it requires a cleint to spe
\item The pproblem with fixed stack is that it only uses strings
to do this we to devolp another class w similar code
\item It is possible to iterate through a Stack
\item Linked list is recsive data structure that is either empy or a refernce to a
node having a generic item and refernce to a node having generic item and
a refernce to a linked list
\item Ex:
\begin{minted}[]{java}
private class Node
{
   Item item;
   Node next;
}
\end{minted}
\item A note has two instance variables: An item and a node
\item You define a node in a class and make it private becuse it is not for use by clients
\item we Use \texttt{new Node()}, results in a new node object with its initial values being null
\item you refer to node instance variables by saying: \texttt{first.item}, \& \texttt{first.next} this
is known as records
\item Below explans how you would build a linked list:
\begin{minted}[]{java}
// you declare your values like this
Node first = new Node();
Node second = new Node();
Node third = new Node();
// you iniialise the values like this, they can take up any data value
first.item = "to";
second.item = "be";
third.item = "or";

// Then you will set the next feilds to
first.next = second;
second.next = third
// Third remains null becuse there is no node after it 
\end{minted}
\item A liked list represents a sequence of items
\item use rectangle system to see each object
Do as follows: \texttt{[to/ ]-> [be/ ] -> [or/(null)]}
\item If you want to insert a new node in the list the best place to do so
is at the beggining of the list
\item Here is how
\begin{minted}[]{java}
// 
 Node oldFirst = first;
 First = new Node();
 first.item = "not";
 first.next = oldfirst;

\end{minted}
\begin{itemize}
\item to remove nodes from the list you can assign the value \texttt{first} to \texttt{first.next}

\item like this:
\begin{minted}[]{java}
first = first.next;
\end{minted}
\begin{itemize}
\item this assing the first value to the value that comes after it
elimating the original value
\item To insert at the end all you have to do is esablish a link to the last node
in the list.

\item Stack, Queue, and Bag implentations for linked lists:
\end{itemize}
\end{itemize}
\end{itemize}


\begin{itemize}
\item Queue implementation basics:
push \& pop: ( add at the begining)
\begin{minted}[]{java}
public void enquene(Item item){

   // adds item to end of the list
   Node oldlast = last;
   last = new Node();
   last.item = item;
   // next element after last is set to null
   last.next = null;
   // is empty checks if frist element is empty 
   if(isEmpty()){

   // sets frist equal to last 

   first = last


   }else{
     // next value after oldlast is set to last 
     oldlast.next = last

   }


 public Item dequene()
{

 // merges with item before it 
 Item item = first.item;
 first = first.next;
 N--;
 if(is.Empty()) last = null;
 return item;
}



}

\end{minted}

\begin{itemize}
\item Stack implementation basics:
push: (add item to the top of the stack)

\begin{minted}[]{java}


 public void push(Item item){

 Node oldFirst = first;
 first = new Node();
 // sets the old note equal to an item
 first.item = item;
 // sets nextNode equal to oldnote
 first.next = oldfirst;


}
\end{minted}
\end{itemize}

\item pop:( remove from the top of the stack)
\end{itemize}


\begin{minted}[]{java}
public Item pop()
{
  Item item = first.item;
  // sets the current first equal to the next item 
  first = first.next;
  N--;
  return item
}
\end{minted}




\begin{itemize}
\item Here is what you can do

\item Here is how:
\begin{minted}[]{java}
Node oldlast = last;
last = new Node();
last.item = "not";
oldlast.next = last;

\end{minted}
\end{itemize}
\begin{itemize}
\item two ways to rpresnt collection of objects are arrays and linked lists
Arrays are built into java, linked lists are easy to build with sandard java
records
\item linked lists are the fundemental alternative to arrays when structureing data

\item To loop through a list you would do this:
\begin{minted}[]{java}
for(Node x=first; x != null; x = x.next){ // Process x.item}

\end{minted}

\item Pracite examples:

\begin{minted}[]{java}
isFull(a.length != N){
    return false;
}
 return true;
\end{minted}
-was best times of the was it  (- most recent element

\begin{itemize}
\item None of the above
\end{itemize}

\item (num 5) the problem prints 110010 the bianry represntation of N

\begin{itemize}
\item While there is a first element in queue it pops thr frist element
and pushes it into stack and vice verse

\item 8 ans: cont 'it', size:9

\item 13 ans: bcd

\item 18: deletes the node net next

\item 22: the code will insert t after x

\item 23: the node after t is x itself
\end{itemize}
\end{itemize}

\chapter{Analysis of Algorithms}
\label{sec:org2bacf43}
\chapter{Case Study: Union-Find}
\label{sec:org7d9466d}

\part{Sorting}
\label{sec:org55be530}
\chapter{Elementary Sorts}
\label{sec:orgd75357f}
\chapter{Merge Sort}
\label{sec:org7e751c7}
\end{document}
